import { v } from "convex/values";
import { action, internalMutation } from "./_generated/server";
import { api } from "./_generated/api";

// Main function to process a ticket - this is the entry point
export const processTicket = action({
  args: {
    ticketId: v.id("tickets"),
    userId: v.optional(v.id("users")),
  },
  handler: async (ctx, args) => {
    // Get ticket and validate access
    const ticket = await ctx.runQuery(api.tickets.getTicket, {
      ticketId: args.ticketId
    });

    if (!ticket) {
      throw new Error("Ticket not found");
    }

    if (args.userId && ticket.userId !== args.userId) {
      throw new Error("User does not have access to this ticket");
    }

    if (ticket.status === "processing") {
      throw new Error("Ticket is already being processed");
    }

    // Create development task
    const task = await ctx.runMutation(api.tickets.assignTicketForDevelopment, {
      ticketId: args.ticketId
    });

    // Start the development workflow asynchronously
    ctx.scheduler.runAfter(0, api.development.runDevelopmentWorkflow, {
      taskId: task._id
    });

    return task;
  },
});

// Create Pull Request for a completed task
export const createPullRequest = action({
  args: {
    taskId: v.id("developmentTasks"),
    userId: v.optional(v.id("users")),
    title: v.optional(v.string()),
    description: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Get task and validate access
    const task = await ctx.runQuery(api.tasks.getTask, {
      taskId: args.taskId
    });

    if (!task) {
      throw new Error("Task not found");
    }

    if (args.userId && task.userId !== args.userId) {
      throw new Error("User does not have access to this task");
    }

    if (task.status !== "completed") {
      throw new Error("Task must be completed before creating a Pull Request");
    }

    if (!task.branchName) {
      throw new Error("Task does not have an associated branch");
    }

    // Get related entities
    const ticket = await ctx.runQuery(api.tickets.getTicket, {
      ticketId: task.ticketId
    });

    const repository = await ctx.runQuery(api.repositories.getRepository, {
      repositoryId: task.repositoryId
    });

    if (!ticket || !repository) {
      throw new Error("Associated ticket or repository not found");
    }

    // Create Pull Request
    const prTitle = args.title || `Fix: ${ticket.title}`;
    const prDescription = args.description || 
      `This PR addresses the following ticket:\n\n**${ticket.title}**\n\n${ticket.description}\n\n---\n\n*Generated by BlackBox AI Bot*\n\nBranch: \`${task.branchName}\`\nCommit: \`${task.commitSha}\``;

    const pullRequest = await ctx.runAction(api.github.createPullRequest, {
      repository,
      branchName: task.branchName,
      title: prTitle,
      description: prDescription,
    });

    // Update task with PR information
    await ctx.runMutation(api.tasks.updateTask, {
      taskId: args.taskId,
      updates: {
        pullRequestUrl: pullRequest.url,
        pullRequestNumber: pullRequest.number,
      }
    });

    // Send notification
    await ctx.runAction(api.notifications.notifyPullRequestCreated, {
      userId: task.userId,
      taskId: args.taskId,
      pullRequestUrl: pullRequest.url,
      pullRequestNumber: pullRequest.number,
    });

    return {
      pullRequestUrl: pullRequest.url,
      pullRequestNumber: pullRequest.number,
      title: prTitle,
      description: prDescription,
    };
  },
});

// Internal workflow that processes the actual development
export const runDevelopmentWorkflow = action({
  args: {
    taskId: v.id("developmentTasks"),
  },
  handler: async (ctx, args) => {
    try {
      // Get task and related entities
      const task = await ctx.runQuery(api.tasks.getTask, {
        taskId: args.taskId
      });

      if (!task) {
        throw new Error("Task not found");
      }

      const ticket = await ctx.runQuery(api.tickets.getTicket, {
        ticketId: task.ticketId
      });

      const repository = await ctx.runQuery(api.repositories.getRepository, {
        repositoryId: task.repositoryId
      });

      if (!ticket || !repository) {
        throw new Error("Associated ticket or repository not found");
      }

      // Step 1: Analyze repository
      await ctx.runMutation(api.tasks.updateTask, {
        taskId: args.taskId,
        updates: { status: "analyzing" }
      });

      const repositoryContext = await ctx.runAction(api.github.getRepositoryContext, {
        repository
      });

      // Step 2: Generate code with BlackBox AI
      await ctx.runMutation(api.tasks.updateTask, {
        taskId: args.taskId,
        updates: { status: "generating" }
      });

      const blackboxResponse = await ctx.runAction(api.blackbox.generateCode, {
        repositoryContext,
        ticketDescription: ticket.description,
        ticketTitle: ticket.title,
      });

      if (!blackboxResponse.success) {
        throw new Error(`BlackBox AI failed: ${blackboxResponse.error}`);
      }

      // Step 3: Commit changes
      await ctx.runMutation(api.tasks.updateTask, {
        taskId: args.taskId,
        updates: { 
          status: "committing",
          blackboxRequestId: blackboxResponse.requestId 
        }
      });

      const branchName = blackboxResponse.generatedCode.branchName || 
        `feature/ticket-${ticket._id}-${Date.now()}`;

      // Create branch
      await ctx.runAction(api.github.createBranch, {
        repository,
        branchName,
        baseBranch: repository.defaultBranch
      });

      // Commit changes
      const commit = await ctx.runAction(api.github.commitChanges, {
        repository,
        branchName,
        changes: blackboxResponse.generatedCode.files,
        commitMessage: blackboxResponse.generatedCode.commitMessage
      });

      // Step 4: Complete the task
      const now = Date.now();
      await ctx.runMutation(api.tasks.updateTask, {
        taskId: args.taskId,
        updates: {
          status: "completed",
          branchName,
          commitSha: commit.sha,
          completedAt: now
        }
      });

      // Update ticket status
      await ctx.runMutation(api.tickets.updateTicket, {
        ticketId: ticket._id,
        updates: {
          status: "completed",
          completedAt: now
        }
      });

      // Send notification
      await ctx.runAction(api.notifications.notifyTaskCompleted, {
        userId: ticket.userId,
        taskId: args.taskId,
        success: true
      });

    } catch (error) {
      // Handle failure
      await ctx.runMutation(api.tasks.updateTask, {
        taskId: args.taskId,
        updates: {
          status: "failed",
          errorMessage: error instanceof Error ? error.message : "Unknown error"
        }
      });

      // Update ticket status
      const task = await ctx.runQuery(api.tasks.getTask, {
        taskId: args.taskId
      });
      
      if (task) {
        await ctx.runMutation(api.tickets.updateTicket, {
          ticketId: task.ticketId,
          updates: { status: "failed" }
        });

        // Send failure notification
        await ctx.runAction(api.notifications.notifyTaskFailed, {
          userId: task.userId,
          taskId: args.taskId,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }

      throw error;
    }
  },
});

// Retry a failed task
export const retryTask = action({
  args: {
    taskId: v.id("developmentTasks"),
    userId: v.optional(v.id("users")),
  },
  handler: async (ctx, args) => {
    const task = await ctx.runQuery(api.tasks.getTask, {
      taskId: args.taskId
    });

    if (!task) {
      throw new Error("Task not found");
    }

    if (args.userId && task.userId !== args.userId) {
      throw new Error("User does not have access to this task");
    }

    if (task.status !== "failed") {
      throw new Error("Task is not in failed state");
    }

    // Reset task to queued
    const retriedTask = await ctx.runMutation(api.tasks.retryFailedTask, {
      taskId: args.taskId
    });

    // Start the workflow again
    ctx.scheduler.runAfter(0, api.development.runDevelopmentWorkflow, {
      taskId: args.taskId
    });

    return retriedTask;
  },
});
