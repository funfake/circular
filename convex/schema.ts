import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // Project Management Tables (from main branch)
  projects: defineTable({
    name: v.string(),
    description: v.string(),
    ownerId: v.string(),
    ownerEmail: v.optional(v.string()),
  }),

  credentials: defineTable({
    projectId: v.id("projects"),
    jiraSourceUrl: v.optional(v.string()),
    githubPersonalAccessToken: v.optional(v.string()),
    repositoryId: v.optional(v.string()),
  }).index("by_project", ["projectId"]),

  invitations: defineTable({
    projectId: v.id("projects"),
    email: v.string(),
    pending: v.boolean(),
  }).index("by_email_pending", ["email", "pending"]),

  members: defineTable({
    projectId: v.id("projects"),
    // Store WorkOS subject (string) instead of Convex Id since we don't keep a users table
    userId: v.optional(v.string()),
    email: v.optional(v.string()),
  })
    .index("by_member", ["userId"])
    .index("by_project_member", ["projectId", "userId"]),

  // Jira Integration Tables
  // we fetch the tickets from Jira
  // if new:
  // 1. create a new ticket
  // 2. analyze the ticket
  // if content is not enough, we reject the ticket (return)
  // if ticket is accepted
  // 3. split the ticket into jobs
  // each job has a title, description, and link to the ticket
  tickets: defineTable({
    projectId: v.id("projects"),
    jiraTitle: v.string(),
    jiraDescription: v.string(),
    jiraId: v.string(),
    rejected: v.optional(v.boolean()), // undefined = not yet analyzed
    rejectionReason: v.optional(v.string()), // reason why the ticket was rejected or approved
    creatingJobs: v.optional(v.boolean()), // true when jobs are being created
  })
    .index("by_project", ["projectId"]) // scope queries by project first
    .index("by_project_jiraId", ["projectId", "jiraId"]), // enable lookups and ordering by jiraId within project

  jobs: defineTable({
    ticketId: v.id("tickets"),
    projectId: v.id("projects"),
    title: v.string(), // generated by the LLM
    tasks: v.string(), // generated by the LLM, list of tasks and sub-tasks
    // if not auto, the user needs to verify the job before it starts
    verifiedAt: v.optional(v.number()), // timestamp when the job is verified by the pm (created ts is set by convex automatically)
    // coding agent fields
    prId: v.optional(v.string()), // github pull request id
    finishedAt: v.optional(v.number()), // timestamp when the job is finished (created ts is set by convex automatically)
  })
    .index("by_ticket", ["ticketId"]) // efficient per-ticket lookups
    .index("by_project", ["projectId"]), // efficient per-project listing

  // BlackBox AI Integration Tables (from HEAD branch)
  // Users table
  users: defineTable({
    email: v.string(),
    name: v.string(),
    githubUsername: v.optional(v.string()),
    createdAt: v.number(),
    updatedAt: v.number(),
  }).index("by_email", ["email"]),

  // Repositories table (GitHub repositories owned by users)
  // Note: Uses bot user authentication instead of individual access tokens
  repositories: defineTable({
    userId: v.id("users"),
    owner: v.string(), // GitHub repo owner
    name: v.string(), // GitHub repo name
    fullName: v.string(), // owner/name
    defaultBranch: v.string(),
    isActive: v.boolean(),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_user_and_name", ["userId", "owner", "name"])
    .index("by_active", ["isActive"]),

  // BlackBox AI Tickets table (separate from Jira tickets for demo purposes)
  blackboxTickets: defineTable({
    userId: v.id("users"),
    repositoryId: v.id("repositories"),
    title: v.string(),
    description: v.string(),
    priority: v.union(
      v.literal("low"),
      v.literal("medium"),
      v.literal("high"),
      v.literal("critical")
    ),
    status: v.union(
      v.literal("pending"),
      v.literal("processing"),
      v.literal("completed"),
      v.literal("failed")
    ),
    assignedAt: v.optional(v.number()),
    completedAt: v.optional(v.number()),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_user", ["userId"])
    .index("by_repository", ["repositoryId"])
    .index("by_status", ["status"])
    .index("by_user_and_status", ["userId", "status"]),

  // Development tasks table
  developmentTasks: defineTable({
    ticketId: v.id("blackboxTickets"),
    repositoryId: v.id("repositories"),
    userId: v.id("users"),
    status: v.union(
      v.literal("queued"),
      v.literal("analyzing"),
      v.literal("generating"),
      v.literal("committing"),
      v.literal("completed"),
      v.literal("failed")
    ),
    branchName: v.optional(v.string()),
    commitSha: v.optional(v.string()),
    errorMessage: v.optional(v.string()),
    blackboxRequestId: v.optional(v.string()),
    pullRequestUrl: v.optional(v.string()),
    pullRequestNumber: v.optional(v.number()),
    startedAt: v.number(),
    completedAt: v.optional(v.number()),
  })
    .index("by_ticket", ["ticketId"])
    .index("by_user", ["userId"])
    .index("by_status", ["status"])
    .index("by_repository", ["repositoryId"]),
});
