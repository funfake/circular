import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  projects: defineTable({
    name: v.string(),
    description: v.string(),
    ownerId: v.string(),
    ownerEmail: v.optional(v.string()),
  }),

  invitations: defineTable({
    projectId: v.id("projects"),
    email: v.string(),
    pending: v.boolean(),
  }).index("by_email_pending", ["email", "pending"]),

  members: defineTable({
    projectId: v.id("projects"),
    // Store WorkOS subject (string) instead of Convex Id since we don't keep a users table
    userId: v.optional(v.string()),
    email: v.optional(v.string()),
  })
    .index("by_member", ["userId"])
    .index("by_project_member", ["projectId", "userId"]),

  // we fetch the tickets from Jira
  // if new:
  // 1. create a new ticket
  // 2. analyze the ticket
  // if content is not enough, we reject the ticket (return)
  // if ticket is accepted
  // 3. split the ticket into jobs
  // each job has a title, description, and link to the ticket
  tickets: defineTable({
    projectId: v.id("projects"),
    jiraTitle: v.string(),
    jiraDescription: v.string(),
    jiraId: v.string(),
    rejected: v.boolean(),
  }),

  jobs: defineTable({
    ticketId: v.id("tickets"),
    projectId: v.id("projects"),
    title: v.string(), // generated by the LLM
    tasks: v.string(), // generated by the LLM, list of tasks and sub-tasks
    // if not auto, the user needs to verify the job before it starts
    verifiedAt: v.number(), // timestamp when the job is verified by the pm (created ts is set by convex automatically)
    // coding agent fields
    prId: v.string(), // github pull request id
    finishedAt: v.number(), // timestamp when the job is finished (created ts is set by convex automatically)
  }),

  credentials: defineTable({
    projectId: v.id("projects"),
    repositoryId: v.string(),
    jiraToken: v.string(),
    githubToken: v.string(),
  }).index("by_project", ["projectId"]),
});
